#### 1. 指向问题クラスとインスタント問題
#### 2. 指向问题
#### 3. リテラル問題
    1. プリミティブ
    2. 参照型
#### 4. ガベージコレクション問題
    1. 参照がない場合、GC対象になる
#### 5,6
1. classファイル 立即-> static
        1. 这个时候非static的不一定存在,因此static不能调用非static
#### 12
1. 返回值类型问题
    1. 假如一个方法返回类型是float,可以用float或者double(有互换性的类型)去接受他
    2. float32位,double64位
#### 14
1. 可变长引数
    1. int ... nums
    2. 只能有一个可变长引数,且必须放在最后
#### 15
1. return文相关问题
    1. void也可以return,但不能加参数
    2. 注意return文后面会发生到达不可的编译错误
#### 16
1. overload问题
    1. 方法名要相同
    2. 引数不同
        1. 类型,数量不同
        2. 顺序不同也算
        3. 但是引数名不同是不算的,JVM不管引数名
    4. 返回类型必须相同
    3. 签名　シグニチャ
        - 方法名和引数的set
#### 17
1. double,int和int,double的问题
    1. double比int大,int可以暗默转double
    2. 即使这样,JVM还是不知道该用哪个方法
    3. 比较暧昧的都判错
#### 18 
1. overide的修饰子问题
    1. override要求方法名相同,引数不同
    2. 只改变修饰子不算override
#### 19
1. 关于构造器方法的修饰子
    1. 没有任何限制,可以是四个的任意一种
2. 四种修饰子
    1. 范围
        1. 本类内部
        2. 本包下
        3. 子类(子类可能在其他包里)
        4. 外部包

    2. 四种修饰子
        1. public,外部包可以看
        2. protected,保护子类,只有外部包不可以看
        3. defalut,只有本包下的可以看
        4. private,只有本类里使用
    3. 修饰子的控制只停留在编译层,不会出现在.class文件中,这意味着通过反射可以在运行时访问任何包任何类
#### 20
1. 注意构造器是没有返回类型的
    1. 如果带了返回类型,即使和类名一样,也会变成一个普通的方法
#### 21
1. 代码块的执行顺序
    1. 初期化子
        1. 可以把构造器里重复的初期化赋值处理放在代码块里,相当于共通前处理
        2. 因此会在所有的构造方法执行前处理,和代码块的位置无关
2. static -》 初期化子 -》 构造方法
    1. 如果没有调用构造方法,初期化子也不会执行
#### 22
1. 可以在一个构造方法里使用this()来调用另一个构造方法,类似于super()
2. 但是!如果使用这种方法,则必须是在构造方法里的第一行使用,否则编译错误
#### 27
1. 修饰子在不同的包下使用的问题