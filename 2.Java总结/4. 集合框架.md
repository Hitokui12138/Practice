## 集合框架
1. 两大接口
    1. Collection,单列,存放单一元素
        1. List,有序可重复
            1. ArrayList,动态数组实现,线程不安全,遍历效率高
            2. LinkedList,双向链表实现,只能顺序访问,插入和删除操作快
                1. 可以基于链表实现栈,队列,双向队列
                2. 扑克牌Demo
            3. Vector,线程安全的ArrayList,但不常用
        2. Set,不可重复
            1. HashSet,无序不重复
                1. 为了确保补重复,需要里面的元素重写equals()和HashCode()方法
                2. User用户名密码不相同Demo
                3. 子类LinkedhashMap,可以确保存取顺序
            2. TreeSet,自动堆存入的数据进行排序,由二叉树实现
                1. 为了实现排序,里面的元素需要实现Comparable或者Comparator
        3. Queue
    2. Map,双列,存放键值对
        - Key是`Set`(不可重复),Value是`Collection`,本身是一个`Entry<Key,Value>`
        1. HashMap,线程不安全
        2. TreeMap,自动对Key进行排序
        3. SortedMap

3. 遍历
    1. Collection的遍历
        1. 迭代器
            1. col.iterator()
                1. it.hasNext()
                2. it.next()
                3. it.remove(),删除迭代器左边元素
            2. 补充:删除重复元素,由于每次删除col.size()都会改变
                1. 使用迭代器的remove,不要和col的remove混用 
                2. 倒序删除
        2. 增强型for循环
            1. for(Object o:col){}
            2. 只是迭代器的语法糖,底层还是迭代器
        3. set.forEach(System.out::print)
    2. Map的遍历
        1. 单独拿到k或者v的集合
            ```java
            Set<String> keys = map.keySet();
            Collection<String> values = map.values();
            for(String s:keys){...}
            for(String s:values){...}
            ``` 
        2. 拿到`Entry<K,V>`,这是一个Set集合
            ```java
            Set<Map.Entry<String,String>> entries = map.entrySet();
            for(Map.Entry<String,String> entry:entries){...}
            ```


4. Collection接口相关方法
    1. collection接口的方法(没有改,因为没有index)
        1. 增(在最后加)
            1. add(obj)
            2. addAll(col)
                - 比如把list加到set里实现去重
        2. 删(不支持index)
            1. remove(obj),注意不能根据index删
            2. removeAll(col)
            3. clear(),清空
        3. 查
            1. contains(),底层是equals(),可以重写
            2. containsAll(col),看看后者是不是子集
        4. 其他
            1. size()
            2. isEmpty()
            3. toArray(T[] arr),参数用来指定类型
            4. iterator(),返回一个迭代器
    2. List(有index)
        - list有序可重复,因此可以使用index,可以使用for循环
        1. 增(插入)
            1. add(index,o)
            2. addAll(index,o)
        2. 删(支持index删除)
            1. remove(index),因为重载,这里总是会删除index的
                - 可以换成包装类来删除元素,remove(new Iteger(XX))
        3. 改
            1. set(index,o)
        4. 查
            1. get(index),查元素
            2. indexOf(o),查位置
            3. indexOfLast(o)
        5. 其他
            1. subList(0,2),左闭右开,取得字串
    3. LinkedList在此基础上多一些操作首尾的方法
        1. 增
            1. addFirst(),addLast()
        2. 删
            1. removeFirst(),removeLast()
        3. 查
            1. removeFirst(),removeLast()
        4. 用LinkedList的操作首尾的方法可以模拟队列等
            1. 单向队列
                1. offer(o),入列到首位
                2. poll(),末尾出列
            2. 栈
                1. push(o),首位入列
                2. poll(),首位出列
                3. peek(),看一下当前首位是什么
    5. set没有额外的方法

5. Map接口相关方法
    1. Map接口
        1. 增,改
            1. put(k,v),既可以添加又可以修改
            2. putAll(map)
        2. 删
            1. remove(k),成功时返回Value
            2. clear(),清空map
        3. 查
            1. get(k)
            2. containsKey(k)
            3. cotainsValue(v)
        4. 其他
            1. size()
            2. isEmpty()
        5. 获取集合
            1. keySet()
            2. values()
            3. entrySet()
6. Collection工具类
    - 可供List,Set,Map使用
    1. reverse(list)
    2. shuffle(list)
    3. sort(list),默认升序
        - sort(list,Comparator)
    4. swap(list,0,4)
    5. max(list)
    6. frequency(list,obj),求出现的次数
    7. copy(nList,oList)    
    8. list = Collections.sychronizedList(list),使线程安全
5. ArrayList详解
    1. 源码
        1. 没有同步方法,线程不安全
        2. 底层是数组(连续空间),遍历的很快
        3. 动态数组的扩容问题
            1. 初始化时,若没有指定长度,则默认创建一个空数组,第一次add的时候创建长度为10的数组
                - 相当于懒汉模式
            2. old+old*2,copy的效率很低,如果想加入100000个元素,只能一一copy
    2. ArrayList与数组[]
        1. ArrayList基于内部动态数组实现,比数组更加灵活,可以根据实际存储的元素扩容,数组创建后不能更改长度
            1. ArrayList创建时不需要指定长度,而数组必须指定长度
        2. ArrayList只能存储对象,数组可以存储对象或者基本类型数据
6. HashSet
    1. Set具有无序性和不可重复性,由equals()实现
    2. 初始化为一个默认长度为16的数组[],延长方法与hashMap有关
    3. 去重的原理(数组+链表)
        1. 计算出来的index的位置上为空时直接存放,假如hashCode为10000,数组长度为16,则10000%16,得到一个0~15的index
        2. 假如元素a算出来的index的位置上已经有另一个元素b了,判断a和b的hashCode是否相同,不同时也可以生成一个链表,放两个元素进去
            1. 首先在这个位置生成一个链表
            2. jdk7之前,b<-a,b是链表的首位
            3. jdk8之后,a<-b,a是链表的首位
        3. 如果hashCode也相同,则需要比较equeals()方法
            1. true,添加失败
            2. false,添加成功
        4. 总结:想办法让不同对象的hashCode也不相同
    4. hashCode()方法的重写原则
        1. 比如现在有一个对象,属性有name和age,通过放大其中一个数,再加上另一个数的方法避免重复
            - return 31 * name.hashCode() + age;
        2. 为什么是31?
            1. 尽可能大的数,地址越大,冲突可能性越小
            2. 31占5bit,2^5=32,虚拟机也有针对优化
            3. 31是个素数
7. TreeSet
    1. 红黑二叉树,加入后自动排序,速度比ArrayList的sort()还快
    2. 去重方法不是equals(),而是由自然排序和定制排序实现
        - 结果为0时不允许插入
        1. 自然排序
            1. Comparable接口
            2. CompareTo()
        2. 定制排序
            1. Comparator
            2. compare()
            3. 可以直接在建TreeSet的时候指定一个比较器
                - new TreeSet<>(new Comparator<XXX>(){...})
    3. 红黑二叉树
        1. 一个节点只能有两个字节点,小的存左边,大的存右边
        2. 如果三个节点都在一边,会自动优化成左右结构
8. Map
    1. 键值对 Entry(`Map.Entry<String,String>`)
    2. Key是Set,不能重复
    3. Value是Collection,可以重复
9. HashMap
    1. 实例化后创建一个长度为16的Entry[]数组
    2. 执行put(k,v)后,计算key的hash值,得到index
        1. 位置为空,直接添加
        2. 不为空但是hashCode()不同,以链表的形式加进去
        3. 相同时,put方法会替换掉旧的value,key不变(新的key不要了)
    3. jdk8后的一些新特性
        1. 实例化后创建Node[]数组,put后才会创建16长度的数组
        2. 数组+链表+红黑树
        3. 形成链表时,7上,8下
        4. 红黑树的形成:
            1. 当某个索引位置上链表的数据>8个
            2. 总长度>64(至少扩容两次后)
            3. 存第九个数据时,会把这个节点改成二叉树
    4. 扩容时机:
        1. 0.75 * 16 = 12
            1. 当存第13个元素时,扩容一倍(16->32)
            2. 扩容时每个数据的位置都会发生变化(hashCode%32)
            3. 这意味着每次扩容都会把所有元素位置重新算一遍,效率低
    5. 统计字母出现次数的demo,字母是k,次数是v
10. HashTable和Properties
    1. 和HashMap差不多,只不过k和v不能为空
    2. 现在主要是用HashTable的子类Properties
    3. Properties常用于读取配置文件
        1. prop.load(new FileInputStream()) 
        2. prop.getProperty(k)
6. StringBuilder详解
    1. 默认是一个长度为16的byte[](jdk9),扩容时直接old*2