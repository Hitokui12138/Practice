# 接口增强
1. 接口最初的核心
    1. 全局常量
    2. 抽象方法
        - 实现接口需要重写所有抽象方法
2. 1.8之后增强
    - 接口业务升级时(增加新方法),这会造成之前的实现类都要改,而且每个类里的新方法几乎相同
    - 过去是 接口-》抽象类-》子类,用抽象类作为接口与自子类之间的一个过渡,这样只要把重复的方法定义在抽象类即可
    1. default定义普通方法
        ```java
        //接口
        interface Book{
            public void read();
            public default void create(){
                sout("XXX");
            }
        }
        //实现类
        class BookImpl implements Book{}
        //调用
        main(){
            Book book = new BookImpl();
            book.create();//使用实现类的实例去调用default()
        }
        ```
    2. static定义静态方法
        - 必须用实力化的对象才能调用default(),因此进一步简化
        ```java
        //接口
        interface Book{
            public void read();
            public default void create(){
                sout("XXX");
            }
            //static,可以返回一个接口实例
            public static Book getInstance(){
                return new BookImpl();
            }
        }
        //实现类
        class BookImpl implements Book{}
        //调用
        main(){
            Book book = new BookImpl();
            book.create();//使用实现类的实例去调用default()
            Book.getInstance().create();//直接用接口名调用static方法
        }
        ```
3. Java1.9之后,接口的private方法
    - 主要用于接口内部调用
    1. 由于不能被继承,因此接口的private方法必须`有实现`
    2. default方法必须是public,因此不能private default
    3. 可以private static
4. 做题
    1. 接口Static方法
        1. 只能`Book.getInstance()`,无论继承类还是实现类都不能调用接口的static方法
        2. 继承类和实现类都不能重写这个方法,是`接口专有的`
    2. 接口Default方法
        1. 默认public
        2. 只能用实现类的`实例`调用default()
        3. 如果想在实现类内部调用
            - `Book.super.create()`,与继承无关,固定写法
        4. A接口有默认方法test(),B父类也有同名的test()
            - 子类C继承B实现A,c.test()时父类B优先
            1. 补充: 父类的test()必须也是public,否则子类C中出错

# 嵌套类
- 内部类,静态内部类,local类,匿名类
### 普通内部类
1. 主要是实力化的方式特殊
    ```java
    Outer o = new Outer();
    Inner i = o.new Inner();
    //简写
    new Outer().new Inner();
    ```
### 静态内部类
1. 实例化
    - 有static所以直接`Inner i = new Inner()`
2. 对Outer的访问
    1. 因为带着static,在实力化之前生成,所以`不能`参照Outer的非static属性方法
    2. 相对的,非Static内部类中也`不能`定义Static属性或方法
### Local类
- 定义在方法中的类,往往会实现一个接口,从而产生方法不同,接口的方法也不同的效果
1. 不能参照Outer的任何属性方法
    - 只能参照方法中定义的东西
2. 对于包围它的方法
    1. 如果想在local类中使用方法中的属性,则这个属性必须在local类的前面定义
    2. 这些属性必须实质final,也就是说定义后不能修改
3. 具体调用
    - 具体调用的时候不需要local class的名字或是实例
    ```java
    class Outer{
        private String msg;
        public Test test(String s){
            msg = s;
            class A implements Test{
                @Override
                public void execute(){
                    sout(msg);
                }
            }
        }
    }
    //调用
    main(){
        new Outer().test("Hello").execute();
    }
    ```
### 匿名类
1. 作用
    1. interface的实现类
    2. abstract的具象类
    3. 直接定义成某个类的子类,继承重写一部分方法
        - 前三者都可以这样写
        ```java
        Sample sample = new Sample(){
            @Override
            //...
        }
        ```
    4. 作为某个类的子类,并添加一个自己的新方法
        ```java
        var sample = new Sample(){
            void add(){...}
        }
        ```
        1. 注意这种时候必须使用`var`,因为父类Sample没有这个新方法
2. 匿名类`不能有构造方法`,但是可以写`初期化子[]`
    