# SpringBatch
2. 核心4个:
    1. JobLaucher,任务启动器
        - いつ呼び出す
    2. `Job`,任务,Stepを順番で呼び出す（１対n）
        - 在 spring batch 的体系当中只是一个最顶层的一个抽象概念
        - 体现在代码当中则它只是一个最上层的接口
        1. 一个或多个`Step`,步骤
            - Taskletを呼び出す（1対1）
            1. ItemReader(读取数据)
            2. ItemProcessor(处理数据)
            3. ItemWriter(写回数据)
        2. Tasklet,実際の処理の実装場所(二つのパターン)
            1. Chunkモデル
            2. Taskletモデル
    3. JobRepository
        1. 可以看作是一个数据库的接口,在JOB和Step执行时可以通过这个来持久化一些信息
        2. SpringBatchの実行履歴、実はDBに専用のTBLを作って、履歴を管理する
            - どうこ失敗、失敗すれば再実行など
#
大枠　深掘り（ふかぼり）
# JOBの実装,Step的顺序(不写业务)
```java
@Configuration
public class SampleBatchConfig{
    /*
        定义JOB,返回类型为Job,参数为JobRepository和要使用的Step(可变长)
        APP执行时就执行这个方法
    */
    @Bean
    private Job sampleJob(JobRepository jobRepository,
                         Step sampleStep1,
                         Step sampleStep2){
        //1. 完全按顺序执行
        return new JobBuilder("sampleJob", jobRepository)//第一个为ID   
                    .start(sampleStep1)//第一个Step
                    .next(sampleStep2)//其他都是next
                    .build();
        
        //2. 简单判断,A成功则执行B,A执行失败则执行C
        // on() -> if
        // from() -> else,结合上一个on()一起使用
        // end() -> 表示Batch`正常`终了,这时是不会记录进Repository的,不能再执行,要注意
        return new JobBuilder("sampleJob", jobRepository)
                    .start(stepA)
                    .on(*).to(stepB)//アスタリスク（Asterisk星号,默认走B
                    .from(stepA).on("FAILED").to(stepC)//若FAILED,则走C
                    .end()
                    .build()
        //3. 如果想让某一步失败后重新执行,应当使用fail()
        //fail()表示Batch`失败停止`,这时会记录进去,并且可以Restart
        return new JobBuilder("sampleJob", jobRepository)
                    .start(stepA)
                    .next(stepB).on("FAILED").fail()
                    .from(stepB).on("*").to(stepC)//若FAILED,则走C
                    .end()
                    .build()
    }
    /*
        定义Step
        PlatformTransactionManager: SpringBatch已经定义好了
        Tasklet: 具体业务,需要自己实现tasklet接口定义
    */
    @Bean
    Step sampleStep(JobRepository jobRepository,
    PlatformTransactionManager transactionManager,
    Tasklet sampleTasklet){
        return new StepBuilder("sampleStep", jobRepository)
            .tasklet(sampleTasklet, transactionManager)//看你要不要事务处理
            .build();
    }
}
```
# Tasklet Model的实装
```java
//实现Tasklet接口和execute()方法
//这里一般会写一些业务,然后再Step中使用这个方法
@Component
public class SampleTasklet implements Tasklet{
    @Override
    public RepeatStatus execute(StepContribution contribution,
                        ChunkContext chunkContext) throws Exception{
        //1. 业务代码

        //2. 最后设置Status,以供on()使用
        //不设置的话默认返回ExitStatus.COMPLETED
        contribution.setExitStatus(ExitStatus.FAILD);//Enum,自定义也可能

        //3. 返回FINISHED表示不要重复,Tasklet终结
        //返回CONTINUABLE,表示再次运行这个Tasklet,但是如果最终没有FINISHED的话,会无限循环
        return RepeatStatus.FINISHED;
        
    }
}
```
# SpringBatch使用的Status(三个)
1. RepeatStatus: 判断Tasklet是否要重复再次执行
    - RepeatStatus.FINISHED
    - RepeatStatus.CONTINUABLE
2. ExitStatus: Tasklet(Step)执行的结果Status(成功还是失败),六个
    1. 默认的六个
        - ExitStatus.EXCUTING,仍在执行中(不需要手动设置,执行结束前都是这个)
        - ExitStatus.COMPLETED,成功完了(默认的,不需要手动设置)
        - ExitStatus.FAILED,业务error,执行失败
        - ExitStatus.NOOP,处理没有执行(可能是不需要执行?)
        - ExitStatus.STOPPED,由于业务error或者异常终了
        - ExitStatus.UNKNOWN,没有明确设置时
    2. 也可以用自己做成的Status
        - new ExitStatus("SKIP")
3. BatchStatus: JOB返回结果,也就是Batch的最终执行结果
    - end()
    - fail()
    1. 状态一览
        - STARTING, 开始前,自动设定
            - STARTED, 自动设定
            - COMPLETED, 没有Error时,自动设置
            - STOPPING, Job.stop()的时候,手动中断
                - STOPPED, 停下来后自动设置,这个状态可以restart
            - FAILED, Job.fail()的时候,这个状态可以restart
            - ABANDONED, 预想之外的error,不可以restart
                - 数据库连接失败,硬件故障等等
            - UNKNOWN,自动设定

# Chunk Model的实装
1. 什么是chunk?チャンク
    1. ItemReader、読み取り、File/DBのデータを取得
        - 参数Bean,read()
    2. ItemProcessor、加工（かこう）、任意
        - 参数是Bean,process()
    3. ItemWriter、書き込み、File/DBを更新　
        - 参数是List<Bean>,write(items)
    - 实装时分别做成这三个类、或者把一个事务做成一套Chunk
    - 在一个chunk里面,一次读入
2. chunk的单位
    1. 如果chunk的单位是2,而csv文件有3个
        1. ItemRead执行一次(读入第一个文件),执行第二次(读入第二个文件)
        2. ItemProcessor执行一次(执行第一个文件),执行第二次(执行第二个文件)
        3. ItemWrite仅执行一次(写入DB)
        4. 因为还有一个csv,所以上面的再进行一次
    2. chunk的使用
        1. 
        ```java
        @Configuration
        public class SampleBatchConfig{
            //sampleJob
            //...
            @Bean
            Step sampleStep(JobRepository jobRepository, PlatformTransActionManager transactionManager){
                return new StepBuilder("sampleStep", jobRepository)
                    .<ReceiveFileInfo, ProcessedFiledInfo> chunk(1000, tM)
                    .reader(iReader)
                    .processor(iProcessor)
                    .writer(iWriter)//为了防止空指针,这些对象应该注入进来
                    .build();
            }
        }
        ```
        2. `.<I, O> chunk(1000, tM)` ジェネリクス
            - I:入力情报的保管Bean
            - O:出力情报的保管Bean
            - 1000:commit单位,也就是Chunk单位
            - tM: transactionManager
    3. ItemReader的使用
        ```java
        
        ```
    