# Hashmap
1. jdk7 
- 实例化后创建一个16长度的Entry[]数组
- map.put(key,value),计算key的hash值,得到存放位置
    1. 位置为空时直接加
    2. 有,但是HashCode不同,以链表形式加进去(数组+链表)
    3. 相同,Set是不让添加,Map是替换掉原来的键值对?(只替换Value,key还是原来那个key,新的key不要了)
    
2. jdk8(4个区别)
1. 实例化后创建Node[]数组
    - 懒汉模式,put后才会创建16长度的数组
2. 以数组+链表+红黑树的方式存储
3. 形成链表时,7上8下
4. 当数组某个索引位置上链表数据>8且总长度>64(扩容两次后,至少128了),存第九个时,就会把这个接点改成二叉树
    - 7则是一直List


# 扩容问题
- 有一些默认的参数
1. 0.75 16*0.75 = 12
    1. 当有12个元素,存第十三个元素时会扩容
    2. 扩容一倍,16->32,而且里面各个数据的位置index会发生变化(因为是hashCode对32取余)
    3. 也就是说每次扩容都会把所有元素的位置重新算一下,效率低(遍历链表)
