# インスタンスとクラス
1. クラスとインスタンス
2. 参照型（がた）変数
3. ガベージコレクション
    1. JVM
        1. JVM将内存分为5个区域
            1. 线程私有区域,每个线程创建时会单独分配这样的内存
                1. 栈Stack
                    - 存储方法运行时的临时变量
                    - 以及对堆内对象的引用(对象的地址,对象名,是个int类型)
                    1. 过程
                        1. main方法入栈
                        2. func方法入栈
                        3. func方法执行完毕,出栈(删除)
                        4. 所有方法执行完毕,main方法出栈
                2. 本地方法区
                    - 存储c++等native方法
                3. 程序计数器
                    - 指向程序当前运行的位置
            2. 全局共享区
                1. 堆Heap
                    - 存放对象,对象的属性(堆内存的属性)都是`有初期值`的
                    1. 过程
                        1. 方法中创建对象,即使方法执行完毕,也只是删除了地址
                        2. 堆中的对象只有在没有地址指向他,且gc刚好运行时才会被清理
                2. 方法区(元空间)
                    - 存储static方法和变量
                    - classLoader等等
        2. ガベージコレクション
            - 堆中的对象只有在没有地址指向他,且gc刚好运行时才会被清理
            
4. staticなフィールドとメソッド
    1. static的属性是所有对象共享一份的,每个对象都可以改这个值,并影响其他对象
    2. static方法和对象会在class初始化时创建,这个时候还没有非static属性
        - 因此static方法不能参照非static属性,也不能使用非static的方法
        - 只能相互参照static修饰的参数和方法
    3. 初期化子,static,顺序
        1. class生成时,初始化static相关
        2. 在方法中使用new来创建一个instance
            - 在生成instance之前,是不会调用初期话子的
        3. 初期化子被调用(可以视为共同的constructor)
        4. 根据参数调用constructor
5. メソッドの呼び出すと定義
    1. 方法定义的必须要素,必须有返回类型
6. メソッドのオーバーロード,重载
    1. 可以改的
        1. 参数的顺序
        2. 参数的类型
        3. 参数的数量(可以少一个参数)
    1. 不能改的东西:
        1. 返回类型不能改
        2. `参数的名称`不能改*
        3. `修饰子`也不能改
7. 可変長引数
    1. 格式
        1. 只能有一个,且必须出现在最后一个参数的位置
        - `int ... values`
8. return文
    1. void的也可以return
    2. 但是return之后再有代码就会报错
9. コンストラクタ
    1. construct的修饰子没有任何限制
    2. construct`不能有返回值`,否则就变成普通的方法了
    3. 没有constructor时会生成默认的
        - 但如果有有参的构造方法,却没有手动创建默认的,则不能调用默认构造器
    4. 不能使用对象去调用构造方法,但是可以在一个constructor里,使用`this()`调用另一个constructor
        - 如果想用this(),super(),则必须在第一行使用
10. アクセス修飾（しゅうしょく）子、（就職）
    1. +public,外部包可以看
    2. #protected,保护子类,只有外部包不可以看
        - 这意味着如果不给父类的属性加protect、不同包下的子类也是看不到的,因为default范围更小
        - 不同包的子类根本不能继承这个属性,更没有初期值
        1. 对于protected修饰的方法
            1. 另一个包子类确实可以在其成员方法中使用这个父类方法
            2. 但是对于和子类一个包的main(),即使创建了子类对象,也不能通过对象.方法()来调用这个protect方法
            3. 这个方法`只有子类内部能用`
    3. ~(defalut),只有本包下的可以看
    4. -private,只有本类里使用
11. カプセル化とデータ隠蔽（いんぺい）
    1. private property;public setter getter
12. 値渡すと参照渡す
    1. 値渡す,里面变,外面不变
    2. 参照渡す,里面变,外面也变



#### 1. 指向问题クラスとインスタント問題
#### 2. 指向问题
#### 3. リテラル問題
    1. プリミティブ
    2. 参照型
#### 4. ガベージコレクション問題
    1. 参照がない場合、GC対象になる
#### 5,6
1. classファイル 立即-> static
        1. 这个时候非static的不一定存在,因此static不能调用非static
#### 12
1. 返回值类型问题
    1. 假如一个方法返回类型是float,可以用float或者double(有互换性的类型)去接受他
    2. float32位,double64位
#### 14
1. 可变长引数
    1. int ... nums
    2. 只能有一个可变长引数,且必须放在最后
#### 15
1. return文相关问题
    1. void也可以return,但不能加参数
    2. 注意return文后面会发生到达不可的编译错误
#### 16
1. overload问题
    1. 方法名要相同
    2. 引数不同
        1. 类型,数量不同
        2. 顺序不同也算
        3. 但是引数名不同是不算的,JVM不管引数名
    4. 返回类型必须相同???
    3. 签名　シグニチャ
        - 方法名和引数的set
#### 17
1. double,int和int,double的问题
    1. double比int大,int可以暗默转double
    2. 即使这样,JVM还是不知道该用哪个方法
    3. 比较暧昧的都判错
#### 18 
1. overide的修饰子问题
    1. override要求方法名相同,引数不同
    2. 只改变修饰子不算override
#### 19
1. 关于构造器方法的修饰子
    1. 没有任何限制,可以是四个的任意一种
2. 四种修饰子
    1. 范围
        1. 本类内部
        2. 本包下
        3. 子类(子类可能在其他包里)
        4. 外部包

    2. 四种修饰子
        1. public,外部包可以看
        2. protected,保护子类,只有外部包不可以看
        3. defalut,只有本包下的可以看
        4. private,只有本类里使用
    3. 修饰子的控制只停留在编译层,不会出现在.class文件中,这意味着通过反射可以在运行时访问任何包任何类
#### 20
1. 注意构造器是没有返回类型的
    1. 如果带了返回类型,即使和类名一样,也会变成一个普通的方法
#### 21
1. 代码块的执行顺序
    1. 初期化子
        1. 可以把构造器里重复的初期化赋值处理放在代码块里,相当于共通前处理
        2. 因此会在所有的构造方法执行前处理,和代码块的位置无关
2. static -》 初期化子 -》 构造方法
    1. 如果没有调用构造方法,初期化子也不会执行
#### 22
1. 可以在一个构造方法里使用this()来调用另一个构造方法,类似于super()
2. 但是!如果使用这种方法,则必须是在构造方法里的第一行使用,否则编译错误!!!
#### 27
1. 修饰子在不同的包下使用的问题