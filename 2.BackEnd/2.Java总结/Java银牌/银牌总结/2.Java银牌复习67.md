# 6 对象与方法
1. static,初期化子,constructor的顺序
    1. 生成class, 先初始化static的变量
    2. 外部调用new关键字试图生成对象
    3. 先调用初期化子
    4. 在调用对应的有参的constractor
2. 构造方法
    1. 不能有任何返回类型
    2. 对于修饰子,`无限制`
    3. 如果想在调用构造方法,则只能在另一个构造方法里调用
        1. 只能使用this(),supper()调用
        2. 且必须啊在第一行调用
3. 关于return
    1. 即使返回类型为void,依然可以return,相当于结束这个方法
    2. 但是return后面如果有其他代码,会出现无法执行到的编译错误
# 7 类的继承, 接口, 抽象类
4. Override 重写
    1. 概念
        1. 方法签名相同(包含了方法的名称、参数列表以及返回类型)
        2. 返回类型可以相同或者子类
        3. 修饰子相同或更宽泛(protect->public)
        4. 抛出异常相同或更狭窄
            1. 若父类为IOException
            2. 子类可以
                1. 抛出相同异常
                2. 抛出FileNotFound等子异常
                3. 干脆不要抛出异常
    2. `final`和`static`的方法不能重写
        - 但是可以创建同名的static方法
5. 多态
    1. 编译时多态 Overload 重载
        1. 只有参数部分是可变的
            1. 参数顺序不同可以重载(需要不同参数类型,因为重载不看参数名称)
            2. 参数数量
            3. 参数类型
        2. 不能变的
            1. 不能只变参数名称
            2. 不能通过改变返回类型实现多态
            3. 不能通过改变修饰子来实现多态
    2. 运行时多态 (基于继承) B->A, A a = new B();
        1. 方法调用
            1. 名义上是A对象,因此不能调用B的方法,不能a.funB(),会编译错误
            2. 实际上是B对象,可以通过转型来变成B,可以(B)a.funB()
                - 由于B是A的子类,因此`(A)b`永远是可行的
                - 仅当上面这一种情况,`(B)a`不报错
            3. 若B类重写过A类方法test(),则a.test()执行的是B类重写过的方法
        2. 参数
            1. a.name -> A
        3. 优点
            - 父类或接口的代码可以重用于多个子类或实现类，减少了代码重复
